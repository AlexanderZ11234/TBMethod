(* ::Package:: *)

BeginPackage["TBMethod`MDConstruct`"]

(* Declare your package's public symbols here. *)

(* Exported symbols added here with SymbolName::usage *) 
HMatrixFromHoppings::usage = "Constructs the real-space tight-binding Hamiltonian matrix from two sets of points from a given hopping function, depending on the coordinates of one pair of points, within the space distance upper limit.";
ParallelHMatrixFromHoppings::usage = "Parallel version of HMatrixFromHoppings."

HMatricesRealSpace::usage = "Generates all the real-space hopping matrices intended to consider."
ParallelHMatricesRealSpace::usage = "Parallel version of HMatricesRealSpace."

HBloch::usage = "Constructs the reciprocal space Bloch Hamiltonian matrix, with automatic consideration of opposite hoppings.";
HBlochFull::usage = "Constructs the reciprocal space Bloch Hamiltonian matrix, without consideration of opposite hoppings.";

DisjointedShellDivisionRegions::usage = "xxx.";

CoordinatesGroupByRegions::usage = "xxx.";

AttachFreeQ::usage = "Checks if two devices are out of contact.";

HCSRDiagOffDiagBlocks::usage = "Generates the n diagonal and the (n-1) first off-diagonal matrix blocks of the tight-binding Hamiltonian, where n is the layer number of the CSR partitioned.";
ParallelHCSRDiagOffDiagBlocks::usage = "Parallel version of HCSRDiagOffDiagBlocks.";
HCSRDiagOffDiagBlocksVerbose::usage = "Verbose version of HCSRDiagOffDiagBlocks.";

HLeadBlocks::usage = "Generates the three Hamiltonian blocks (\!\(\*SubscriptBox[\(h\), \(00\)]\), \!\(\*SubscriptBox[\(h\), \(10\)]\), and \!\(\*SubscriptBox[\(H\), \(10\)]\)) for each lead.";
ParallelHLeadBlocks::usage = "Parallel version of HLeadBlocks.";
HLeadBlocksVerbose::usage = "Verbose version of HLeadBlocks.";

AdaptivePartition::usage = "Partitions the CSR in an adaptive way to achieve an optimal slicing status, according to the given leads' configuration."

\[CapitalGamma]Matrix::usage = "Generates matrices from Kronecker product of Pauli matrices, used in construction of Dirac model.";

FillWithDistance::usage = "Constructs the piecewise filling function according to distances."
FillWithCondition::usage = "Constructs the piecewise filling function according to conditions."

PhaseFactor2DAB::usage = "Calculates the Aharonov-Bohm (AB) phase for a magnetic flux along z-direction according to Peierls' substitution, with an eye on the lattice translational symmetry along one inplane direction.";
PhaseFactor3DAB::usage = "Calculates the Aharonov-Bohm (AB) phase for a magnetic flux along an arbitrary direction according to Peierls' substitution.";

HBlochsForSpecFunc::usage = "Constructs Bloch Hamiltonian blocks for calculation of spectral function (LDOS in reciprocal space).";

GellMannMatrix::usage = "Gives Gell-Mann matrices.";
PauliGellMannDecomposition::usage = "Decomposes a matrix into a sum of linear conbination of a series of matrix basis, which are Kronecker products of Pauli and/or Gell-Mann matrices.";
PauliGellMannAbstract::usage = "Formats tidily the information generated by PauliGellMannDecomposition.";
PauliGellMannRepresent::usage = "Transforms the result of PauliGellMannAbstract into its matrix representation.";

PhotonBlocks::usage = "Generates the Floquet dressing coefficient for a certain hopping amplitude due to light driven field via Peierls's substitution.";
PhotonDress::usage = "Generates the photon-dressed hopping amplitude.";

CompiledSuccessfulQ::usage = "Checks if a function compilation process succeeds.";

CrystalStructure::usage = "Generates the crystal structure by the composition of lattice and basis.";

HEffectiveMatrix::usage = "Generates lower-energy effective Hamiltonian matrix via Taylor expasion, in terms of linear combination of Pauli and/or GellMann matrices.";

LatticePointsCentralize::usage = "Aligns the centroid of a primitive cell with lattice points to the origin.";

HFloquetEffectiveBlochMatrixFromExtended::usage = "Constructs the effective Floquet-Bloch Hamiltonian matrix from the extended Floquet-Bloch Hamiltonian matrix under the high-frequencey approximation.";
HFloquetEffectiveHoppingMatricesFromExtended::usage = "Constructs the effective real-space hopping matrices from the extended real-space hopping matrices under the high-frequencey approximation.";

AdatomLabel::usage = "Adds labels to an atom depending on whether it is influenced by an adatom.";

HCSRBlocksAndersonDisordered::usage = "Generates CSR ensembles with Anderson disorders from the nondisordered CSR Hamiltonian blocks."

SlaterKosterOnsiteBlock::usage = "Constructs the onsite matrix block in the Slater-Koster formalism."
SlaterKosterHoppingBlock::usage = "Constructs the hopping matrix block in the Slater-Koster formalism."

SlaterKosterSOCOnsiteBlock::usage = "Constructs the onsite SOC matrix block in the Slater-Koster formalism."


Begin["`Private`"]
(* Implementation of the package *)
(*SetOptions[{ParallelSum}, Method -> "ItemsPerEvaluation" -> 100 $KernelCount];*)

$DistributedContexts = {"Global`", "TBMethod`"}; (*Otherwise, dim in HMatrixFromHoppings is not working in parallel subkernels. This is very IMPORTANT!!!*)


FillWithDistance[fs_, ds_, d_, zero_:1.*^-5] :=
Module[{innerdof = Dimensions[fs[[1, 1]]]},
	Piecewise[
	MapThread[{#, Abs[d - #2] < zero} &, {fs, ds}],
	ConstantArray[0, innerdof]
	] // ReleaseHold
];
FillWithCondition[fs_, conds_] :=
Module[{innerdof = Dimensions[fs[[1, 1]]]},
	Piecewise[
		{fs, conds}\[Transpose],
		ConstantArray[0, innerdof]
	] // ReleaseHold
];

(*\[CapitalGamma]Matrix[is__] := KroneckerProduct @@ PauliMatrix[{is}];*)
\[CapitalGamma]Matrix[is__] := If[Length[{is}] == 1, PauliMatrix[is],
					KroneckerProduct @@ PauliMatrix[{is}]
					];

(*Phys. Rev. B 40, 8169 (1989)*)
(*The azimuthal angle \[Phi]A specifies the direction respecting the lattice translational symmetry,
	even in the presence of the vector potential.*)
(*Gauge: vecA = (-B y, 0, 0)*)
PhaseFactor2DAB[B_, \[Phi]A_][ptf:{_, _}, pti:{_, _}] :=
Module[{xi, yi, xj, yj, \[CurlyPhi]},
	{{xi, yi}, {xj, yj}} = {ptf, pti};
	(*B \[Pi] ( xj yi - xi yj - (xi yi - xj yj) Cos[2\[Phi]A] + (xi^2 - xj^2 - yi^2 + yj^2) Sin[2\[Phi]A]/2)*)
	\[CurlyPhi] = B \[Pi] (- xj yi + xi yj + (xi yi - xj yj) Cos[2\[Phi]A] + (-xi^2 + xj^2 + yi^2 - yj^2) Sin[2\[Phi]A]/2);
	Exp[I \[CurlyPhi]]
];

(* \[CapitalPhi]0 = h/q is the magnetic flux quantum for a particle with the electric charge q.*)
(*Gauge: vecA = (1/2) vecB \[Cross] vecr*)
PhaseFactor3DAB[Bz_][ptf:{_, _}, pti:{_, _}] := PhaseFactor3DAB[{0, 0, Bz}][Append[ptf, 0], Append[pti, 0]]
PhaseFactor3DAB[vecB:{_, _, _}][ptf:{_, _, _}, pti:{_, _, _}] :=
Module[{\[CurlyPhi]},
	\[CurlyPhi] = (*2/(2 \[CapitalPhi]0)*)\[Pi] Det[{ptf, vecB, pti}];
	Exp[I \[CurlyPhi]]
];

SetAttributes[GellMannMatrix, Listable]
GellMannMatrix[i : Alternatives @@ Range[0, 8]] :=
Module[{n = 3, dim},
	dim = {1, 1} n;
	Which[
		i == 0, IdentityMatrix[n, SparseArray],
		i == 1 || i == 2 || i == 3, SparseArray[PadRight[PauliMatrix[i], dim]],
		i == 4, SparseArray[{{1, 3}, {3, 1}} -> 1, dim],
		i == 5, SparseArray[{{1, 3} -> -I, {3, 1} -> I}, dim],
		i == 6 || i == 7, SparseArray[PadLeft[PauliMatrix[i - 5], dim]],
		i == 8, SparseArray[Band[{1, 1}] -> ({1, 1, -2}/Sqrt[3]), dim]
	]
];


pauliMatrixDecomposition[{{a_, b_}, {c_, d_}}] := FullSimplify[{a + d, b + c, I(b - c), a - d}/2];
gellMannMatrixDecomposition[{{a_, b_, c_}, {d_, e_, f_}, {g_, h_, i_}}] := FullSimplify[{2(a + e + i)/3, b + d, I (b - d), a - e, c + g, I(c - g), f + h, I(f - h), (a + e - 2i)/Sqrt[3]}/2];
dimfatorpattern = ({{2, _Integer}} | {{3, _Integer}} | {{2, _Integer}, {3, _Integer}});
PauliGellMannDecomposition[M_?MatrixQ, dimlist:{(2|3)..}] /; (# == #2 >= 2 && MatchQ[FactorInteger[#], dimfatorpattern] & @@ Dimensions[M]):=
Module[{decompose, rules},
	decompose[n:(2|3)] := If[n == 2, pauliMatrixDecomposition, gellMannMatrixDecomposition];
	rules = ArrayRules[Fold[BlockMap[decompose[#2], #, {1, 1} #2] &][M, Reverse @ dimlist][[1, 1]]];
	Association[MapAt[# - 1 &, {;;, 1}] @ Most[rules]]
];

PauliGellMannAbstract[PGMDecomp_Association, dimlist:{(2|3)..}] :=
Module[{s, keyfunc},
	s[n:(2|3)] := If[n == 2, "\[Sigma]", "\[Lambda]"];
	keyfunc = CircleTimes @@ MapThread[Construct, {s /@ dimlist, #}] &;
	Total[KeyValueMap[keyfunc[#] #2 &][PGMDecomp]] /. CircleTimes[x_] :> x
];

PauliGellMannRepresent[epr_] := FullSimplify[epr /. {"\[Sigma]" -> PauliMatrix, "\[Lambda]" -> GellMannMatrix, CircleTimes -> KroneckerProduct}];


(*Auxiliary functions*)
(*coordspattern = {{__?NumericQ}..|{{__?NumericQ}, True|False}..|(_ -> {__?NumericQ})..};*)
(*coordspattern = {{__?NumericQ}..|(_ -> {__?NumericQ})..};*)
(*coordspattern={{__?NumericQ}..}|{Rule[_, {__?NumericQ}]..};*)
coordspattern = {__List} | {Rule[_ , _List]..};
(*Extra information is typically of the "onsite energy like", and can be: (1) atom on bdr or not; (2) atom mass*)
(*the one containing booleans should be removed*)

(*neighbourInfos[pts:coordspattern, dist_Real] := neighbourInfos[{pts, pts}, dist];*)(*This kind of pattern splitting leads to ambiguity.*)
neighbourInfos[fipts:{fpts:coordspattern, ipts:coordspattern}, dist_Real] := neighbourInfos[fipts, dist] =
Module[{fptsnobool, iptsnobool, nfunc, a0 = 1},
	{fptsnobool, iptsnobool} = If[FreeQ[#, (*True|False*)Rule[_, _]], #, Values[#]]& /@ fipts;
	(*{fptsnobool, iptsnobool} = If[Head[#] === List, #, Values[#]]& /@ fipts;*)
	nfunc = Nearest[iptsnobool -> Automatic, WorkingPrecision -> MachinePrecision, Method -> "KDTree"];
	Flatten[MapIndexed[Thread[{#2[[1]], #}]&, nfunc[fptsnobool, {All, dist a0}]], 1]
];

AttachFreeQ[fipts:{fpts:coordspattern, ipts:coordspattern}, dist_Real] := Length[neighbourInfos[fipts, dist]] == 0;

(*HMatrixFromHoppings[pts:coordspattern, tFunc_, dist_Real, sumfunc_:Sum] := HMatrixFromHoppings[{pts, pts}, tFunc, dist, sumfunc];*)
(*General::maxrec: "Recursion limit exceeded; positive match might be missed."*)

HMatrixFromHoppings[fipts:{fpts:coordspattern, ipts:coordspattern}, tFunc_, dist_Real] :=
Block[{dim = Length /@ fipts, neighbourinfos = neighbourInfos[fipts, dist], len, (*lenup = 1000,*) summand},
	len = Length[neighbourinfos];
	summand[ij_] := KroneckerProduct[SparseArray[ij -> 1, dim], tFunc[fpts[[#]], ipts[[#2]]] & @@ ij];
	Which[
		len == 0, KroneckerProduct[SparseArray[{}, dim], tFunc[fpts[[1]], ipts[[1]]]],
		len > 0 , Sum[summand[ij], {ij, neighbourinfos}]
	]
];

ParallelHMatrixFromHoppings[fipts:{fpts:coordspattern, ipts:coordspattern}, tFunc_, dist_Real, ops:OptionsPattern[ParallelSum]] :=
Block[{dim = Length /@ fipts, neighbourinfos = neighbourInfos[fipts, dist], len, (*lenup = 1000,*) summand},
	len = Length[neighbourinfos];
	summand[ij_] := KroneckerProduct[SparseArray[ij -> 1, dim], tFunc[fpts[[#]], ipts[[#2]]] & @@ ij];
	Which[
		len == 0, KroneckerProduct[SparseArray[{}, dim], tFunc[fpts[[1]], ipts[[1]]]],
		len > 0 , ParallelSum[summand[ij], {ij, neighbourinfos}, ops]
	]
];


(*HMatrixFromHoppings[fipts:{fpts:coordspattern, ipts:coordspattern}, tFunc_, dist_Real, sumfunc_:Sum] :=
Block[{dim = Length /@ fipts, neighbourinfos = neighbourInfos[fipts, dist], len, (*lenup = 1000,*) summand},
	len = Length[neighbourinfos];
	summand[ij_] := KroneckerProduct[SparseArray[ij -> 1, dim], tFunc[fpts[[#]], ipts[[#2]]] & @@ ij];
	(*Which[
		len == 0, KroneckerProduct[SparseArray[{}, dim], tFunc[fpts[[1]], ipts[[1]]]],
		lenup > len > 0, Sum[summand[ij], {ij, neighbourinfos}],
		lenup <= len, ParallelSum[summand[ij], {ij, neighbourinfos}]
	]*)
	Which[
		len == 0, KroneckerProduct[SparseArray[{}, dim], tFunc[fpts[[1]], ipts[[1]]]],
		len > 0 , sumfunc[summand[ij], {ij, neighbourinfos}]
	]
];*)

(*HMatrixFromHoppings[pts:coordspattern, tFunc_, dist_Real] := HMatrixFromHoppings[{pts, pts}, tFunc, dist];
HMatrixFromHoppings[fipts:{fpts:coordspattern, ipts:coordspattern}, tFunc_, dist_Real] :=
Module[{dim = Length /@ fipts, fptsnobool, iptsnobool, nfunc, neighbourinfos, fillingrules, a0 = 1},
	{fptsnobool, iptsnobool} = If[FreeQ[#, True|False], #, #[[;;, 1]]]& /@ fipts;
	(*nfunc is a NearestFunction with respect to the group of initial points, which should constitute the column index*)
	nfunc = Nearest[iptsnobool -> Automatic, WorkingPrecision -> MachinePrecision(*Method -> Automatic(*{"KDtree","LeafSize"->50}*)*)];
	(*Within the disk/ball with a certain radius (= dist a0) centered at each final point, find the encompassed initial points; each point is given as its index in its corresponding ordered set (final point in fpts & initial point in ipts).*)
	neighbourinfos = Flatten[MapIndexed[Thread[{#2[[1]], #}]&, nfunc[fptsnobool, {All, dist a0}]], 1];(*{{j..}..} -> {{i, {j..}}..} -> {{i, j}..}*)
	
	(*Summation saves RAM considerably. Fine tunability lies in the methods of Parallelize[]*)
	If[Length[neighbourinfos] < 1000, Sum, ParallelSum][
		KroneckerProduct[SparseArray[ij -> 1, dim], tFunc[fpts[[#]], ipts[[#2]]]& @@ ij],
		{ij, neighbourinfos}
	]
];*)

HMatricesRealSpace[crystalstructure_Association, tfunc_, dup_Real] := (pts |-> HMatrixFromHoppings[{pts, crystalstructure[[1]]}, tfunc, dup]) /@ crystalstructure;
ParallelHMatricesRealSpace[crystalstructure_Association, tfunc_, dup_Real] := (pts |-> ParallelHMatrixFromHoppings[{pts, crystalstructure[[1]]}, tfunc, dup]) /@ crystalstructure;


HBloch[vk_, h0010s:<|({__?NumericQ} -> _SparseArray)..|>] :=
Module[{hermitize = # + #\[HermitianConjugate] &},
	First[h0010s] + hermitize[KeyValueMap[Exp[I # . vk] #2 &, Rest[h0010s]] // Total]
];

HBlochFull[vk_, vecaHa_Association] := Total[KeyValueMap[Exp[I # . vk] #2 &, vecaHa]];

(*Division of a large central scattering region in a disjointed covering manner, suitable for 2D & 3D*)
DisjointedShellDivisionRegions[region_?BoundaryMeshRegionQ, nregions_?(# \[Element] PositiveIntegers &)] :=
Module[{scalingfunc, scaledregions, scalingfactors = Most @ Subdivide[1, 0, nregions], regdim = RegionDimension[region]},
	scalingfunc[factor_] := ScalingTransform[ConstantArray[factor, regdim], RegionCentroid[region]];
	scaledregions = TransformedRegion[region, scalingfunc[#]] & /@ scalingfactors;
	Reverse @ BlockMap[RegionDifference, Append[scaledregions, EmptyRegion[regdim]], 2, 1]
];

CoordinatesGroupByRegions[pts:coordspattern, regions_List] :=
Module[{indexesraw, indexes, intersectionindexes, ptsdata},
	ptsdata = If[\[Not]FreeQ[pts, Rule], Values[pts], pts];
	(*label by regions*)
	indexesraw = GroupBy[SparseArray[Boole @ RegionMember[#][ptsdata] & /@ regions]["NonzeroPositions"], First -> Last];
	(*delete duplecates*)
	intersectionindexes = MapIndexed[#2[[1]] -> # &, Prepend[BlockMap[Intersection @@ # &, indexesraw, 2, 1], {}]];
	indexes = Merge[{indexesraw, intersectionindexes}, DeleteCases[#, Alternatives @@ #2] & @@ # &];
	Extract[pts, {#}\[Transpose]] & /@ indexes
];

HCSRDiagOffDiagBlocks[CSRptsgrouped_Association, tFunc_, dup_] :=
Module[{hdfill, hofill, hdblocks, hoblocks, (*attachcheck, checkresults,*) csrpts = Values[CSRptsgrouped], len = Length[CSRptsgrouped]},
	If[len == 1, HMatrixFromHoppings[Join[csrpts, csrpts], tFunc, dup],
		((*attachcheck = ({p1, p2, p3} |-> AttachFreeQ[{p1, p3}, dup]) @@ # &;
		checkresults = And @@ BlockMap[attachcheck, csrpts, 3, 1];*)
		(*Echo[StringTemplate["Attach check passed: ``."][checkresults]];
		If[checkresults,
			hdfill = p |-> HMatrixFromHoppings[{p, p}, tFunc, dup];
			hofill = p |-> HMatrixFromHoppings[Reverse @ p, tFunc, dup];
			hdblocks = hdfill /@ csrpts;
			hoblocks = BlockMap[hofill, csrpts, 2, 1];
			{hdblocks, hoblocks},
			Echo["Reduce the division number of CSR."]
		])*)
		hdfill = p |-> HMatrixFromHoppings[{p, p}, tFunc, dup];
		hofill = p |-> HMatrixFromHoppings[Reverse @ p, tFunc, dup];
		hdblocks = hdfill /@ csrpts;
		hoblocks = BlockMap[hofill, csrpts, 2, 1];
		{hdblocks, hoblocks})
	]
];

(*ParallelHCSRDiagOffDiagBlocks[CSRptsgrouped_Association, tFunc_, dup_] :=
Module[{hdfill, hofill, hdblocks, hoblocks, csrpts = Values[CSRptsgrouped], len = Length[CSRptsgrouped]},
	If[len == 1, HMatrixFromHoppings[Join[csrpts, csrpts], tFunc, dup],
		(hdfill = p |-> HMatrixFromHoppings[{p, p}, tFunc, dup];
		hofill = p |-> HMatrixFromHoppings[p, tFunc, dup];
		hdblocks = hdfill ~ParallelMap~ csrpts;
		hoblocks = hofill ~ParallelMap~ Transpose[{Rest[csrpts], Most[csrpts]}];
		(*hoblocks = Parallelize[MapThread[hofill @* List, {Rest[csrpts], Most[csrpts]}]];*)
		{hdblocks, hoblocks})
	]
];*)
ParallelHCSRDiagOffDiagBlocks[CSRptsgrouped_Association, tFunc_, dup_] :=
Module[{hdfill, hofill, hdblocks, hoblocks, csrpts = Values[CSRptsgrouped], len = Length[CSRptsgrouped]},
	If[len == 1, HMatrixFromHoppings[Join[csrpts, csrpts], tFunc, dup],
		(hdfill = p |-> ParallelHMatrixFromHoppings[{p, p}, tFunc, dup];
		hofill = p |-> ParallelHMatrixFromHoppings[Reverse @ p, tFunc, dup];
		hdblocks = hdfill ~Map~ csrpts;
		hoblocks = BlockMap[hofill, csrpts, 2, 1];
		{hdblocks, hoblocks})
	]
];

HCSRDiagOffDiagBlocksVerbose[CSRptsgrouped_Association, tFunc_, dup_] :=
Module[{hdfill, hofill, hdblocks, hoblocks, attachcheck, checkresults, csrpts = Values[CSRptsgrouped], len = Length[CSRptsgrouped]},
	If[len == 1, HMatrixFromHoppings[Join[csrpts, csrpts], tFunc, dup],
		(attachcheck = ({p1, p2, p3} |-> AttachFreeQ[{p1, p3}, dup]) @@ # &;
		checkresults = And @@ BlockMap[attachcheck, csrpts, 3, 1];
		Echo[StringTemplate["Attach check passed: ``."][checkresults]];
		If[checkresults,
			hdfill = p |-> HMatrixFromHoppings[{p, p}, tFunc, dup];
			hofill = p |-> HMatrixFromHoppings[Reverse @ p, tFunc, dup];
			hdblocks = hdfill /@ csrpts;
			hoblocks = BlockMap[hofill, csrpts, 2, 1];
			{hdblocks, hoblocks},
			Echo["Reduce the division number of CSR."]
		])
	]
];

(*HLeadBlocks[CSRptsgrouped_Association, tFunc_, dup_, leadpts_] := Table[HMatrixFromHoppings[fipts, tFunc, dup], {fipts, {{#[[1]], #[[1]]}, #, {Values[CSRptsgrouped][[-1]], #[[1]]}} & [leadpts]}];*)
HLeadBlocks[CSRptsgrouped_Association, tFunc_, dup_, leadpts_] := Table[HMatrixFromHoppings[fipts, tFunc, dup], {fipts, {{#[[1]], #[[1]]}, #, {CSRptsgrouped[[-1]], #[[1]]}} & [leadpts]}];
ParallelHLeadBlocks[CSRptsgrouped_Association, tFunc_, dup_, leadpts_] := Table[ParallelHMatrixFromHoppings[fipts, tFunc, dup], {fipts, {{#[[1]], #[[1]]}, #, {CSRptsgrouped[[-1]], #[[1]]}} & [leadpts]}];

HLeadBlocksVerbose[CSRptsgrouped_Association, tFunc_, dup_, leadpts_, leadname_String] :=
Module[{attachcheck, checkresults, csrtwoouters = Values[CSRptsgrouped][[{-2, -1}]]},
	attachcheck = p |-> AttachFreeQ[p, dup];
	checkresults = attachcheck /@ ({csrtwoouters, leadpts}\[Transpose]);
	Echo[StringTemplate["Cell 0 of Lead `` attach check passed: ``."][leadname, checkresults[[1]]]];
	Echo[StringTemplate["Cell 1 of Lead `` attach check passed: ``."][leadname, checkresults[[2]]]];
	If[And @@ checkresults,
		Table[HMatrixFromHoppings[fipts, tFunc, dup], {fipts, {{#[[1]], #[[1]]}, #, {csrtwoouters[[-1]], #[[1]]}} & [leadpts]}],
		Echo[StringTemplate["Enlarge the cell of Lead `` and/or reduce the division number of CSR."][leadname]]
	]
];

(*adaptive partition of CSR*)
(*Points in CSR without labels*)
(*AdaptivePartition[{ptslead1stcell_, ptscsr:coordspattern[[{1}, 1]]}, dup_] :=
Module[{groupfunc, iterate, ptscsrgrouped},
	groupfunc[{x_, y_}] := Module[{ptsneighbors, layerneighbors},
		ptsneighbors = Join @@ NearestTo[x, {All, dup}, WorkingPrecision -> MachinePrecision, Method -> "KDTree"][y];
		layerneighbors = DeleteDuplicates[ptsneighbors];
		{x, {#, Complement[y, #]}} & [layerneighbors]
	];
	iterate = FlattenAt[-1] @* SubsetMap[groupfunc, -2;;];
	(*ptscsrgrouped = NestWhile[iterate, {ptslead1stcell, ptscsr}, Last[#] != {} &][[2;;-2]];*)
	ptscsrgrouped = Rest @ NestWhile[iterate, {ptslead1stcell, ptscsr}, Last[#] != {} &, 1, \[Infinity], -1];
	<|MapIndexed[#2[[1]] -> # &, Reverse[ptscsrgrouped]]|>
];
(*Points in CSR with labels: this second version actually works for both patterns, but slower than the first version for the first pattern.*)
AdaptivePartition[ptsleadcsr:{ptslead1stcell_, ptscsr:coordspattern[[{1}, 2]]}, dup_] :=
Module[{neighborindex, indexneighbortolead, indexgrouped, iterate, ptsleadnobool, ptscsrnobool, indexlayered, len = Length[ptscsr], nf},
	{ptsleadnobool, ptscsrnobool} = If[FreeQ[#, Rule[_, _]], #, Values[#]] & /@ ptsleadcsr;
	nf = Nearest[ptscsrnobool -> Automatic, WorkingPrecision -> MachinePrecision, Method -> "KDTree"];
	neighborindex[x_] := DeleteDuplicates @* Join @@ nf[x, {All, dup}];
	indexneighbortolead = neighborindex[ptsleadnobool];
	iterate = neighborindex[ptscsrnobool[[#]]] &;
	indexgrouped = Reverse @ NestWhileList[iterate, indexneighbortolead, Length[#] < len &];
	indexlayered = BlockMap[Complement @@ # &, Append[indexgrouped, {}], 2, 1];
	<|MapIndexed[#2[[1]] -> ptscsr[[#]] &, indexlayered]|>
]*)
(*optimal implementation so far*)
AdaptivePartition[ptsleadcsr:{ptslead1stcell:coordspattern, ptscsr:coordspattern}, dup_] :=
Module[{neighborindex, nf, indexgrouped, iterate, ptsleadnobool, ptscsrnobool, indexlayered, initial},
	{ptsleadnobool, ptscsrnobool} = If[FreeQ[#, Rule[_, _]], #, Values[#]] & /@ ptsleadcsr;
	nf = Nearest[ptscsrnobool -> Automatic, WorkingPrecision -> MachinePrecision, Method -> "KDTree"];
	neighborindex[x_] := DeleteDuplicates @* Join @@ nf[x, {All, dup}];
	iterate = Append[#, Complement[neighborindex[ptscsrnobool[[Last[#]]]], #[[-1]], #[[-2]]]] &;
	initial = {{}, neighborindex[ptsleadnobool]};
	indexlayered = Reverse @ Rest @ NestWhile[iterate, initial, Last[#] != {} &, 1, \[Infinity], -1];
	<|MapIndexed[#2[[1]] -> ptscsr[[#]] &, indexlayered]|>
];
(*AdaptivePartition[ptsleadcsr:{ptslead1stcell:coordspattern, ptscsr:coordspattern}, dup_, opts: OptionsPattern[Nearest]] :=
Module[{neighborindex, nf, indexgrouped, iterate, ptsleadnobool, ptscsrnobool, indexlayered, initial},
	{ptsleadnobool, ptscsrnobool} = If[FreeQ[#, Rule[_, _]], #, Values[#]] & /@ ptsleadcsr;
	nf = Nearest[ptscsrnobool -> Automatic, opts, WorkingPrecision -> MachinePrecision, Method -> "KDTree"];
	neighborindex[x_] := DeleteDuplicates @* Join @@ nf[x, {All, dup}];
	iterate = Append[#, Complement[neighborindex[ptscsrnobool[[Last[#]]]], #[[-1]], #[[-2]]]] &;
	initial = {{}, neighborindex[ptsleadnobool]};
	indexlayered = Reverse @ Rest @ NestWhile[iterate, initial, Last[#] != {} &, 1, \[Infinity], -1];
	<|MapIndexed[#2[[1]] -> ptscsr[[#]] &, indexlayered]|>
];*)

(*HBlochsForSpecFunc[vk_, ptscellsvas_, tfunc_, dup_] :=
Module[{HLeadIntraInterReal, HCSRIntraLeadInterReal, fillfunc, keys = Keys[ptscellsvas], len = Length[ptscellsvas]},
	fillfunc[indfs_, indi_] := HMatrixFromHoppings[{#, ptscellsvas[[indi]]}, tfunc, dup] & /@ KeyMap[# - keys[[indi]] &][ptscellsvas[[indfs]]];
	(*fillfunc[indfs_, indi_] := HMatrixFromHoppings[{#, ptscellsvas[[indi]]}, tfunc, dup] & /@ ptscellsvas[[indfs]];*)
	HLeadIntraInterReal = fillfunc @@@ {{2;;4, 3}, {2;;4, 1}};
	Which[
		len == 4, HBlochFull[vk, #]& /@ HLeadIntraInterReal,
		len == 7,
		(HCSRIntraLeadInterReal = fillfunc @@@ {{5;;, 6}, {5;;, 3}};
		Map[HBlochFull[vk, #]&, {HLeadIntraInterReal, HCSRIntraLeadInterReal}, {2}]),
		True, 0
	]
];*)

HBlochsForSpecFunc[vk:({_, _}|{_, _, _}), bdrdirec:({_, _}|{_, _, _}), ptscellsvasraw_, tfunc_, dup_] :=
Module[{HLeadIntraInterReal, HCSRIntraLeadInterReal, fillfunc, keys, len = Length[ptscellsvasraw], ptscellsvas},
	(*ptscellsvas = Association /@ SortBy[N @* Norm @* Keys] /@ GatherBy[Normal[ptscellsvasraw], Norm[Keys[#] . bdrdirec] &];*)
	ptscellsvas = Association /@ SortBy[N @* Norm @* Keys] /@ GatherBy[Normal[ptscellsvasraw], Norm[Projection[Keys[#], bdrdirec]] &];
	(*KeyMap only works on Association, rather than List.*)
	keys = Keys[ptscellsvas];
	fillfunc[indfs_, indi_] := HMatrixFromHoppings[{#, Extract[indi] @ ptscellsvas}, tfunc, dup] & /@ (KeyMap[# - Extract[indi][keys] &] @ ptscellsvas[[indfs]]);
	HLeadIntraInterReal = fillfunc @@@ {{2, {2, 1}}, {2, {1, 1}}};
	Which[
		MemberQ[{4, 8, 10}, len],
		HBlochFull[vk, #] & /@ HLeadIntraInterReal,
		MemberQ[{7, 15, 19}, len],
		(HCSRIntraLeadInterReal = fillfunc @@@ {{3, {3, 1}}, {3, {2, 1}}};
		Map[HBlochFull[vk, #] &, {HLeadIntraInterReal, HCSRIntraLeadInterReal}, {2}]),
		True, 0
	]
] /; MemberQ[{4, 7, 8, 10, 15, 19}, Length[ptscellsvasraw]];
(*
necessary number of cells to consider: 2D: 1->3(->3) (for square lattice); 3D: 1->9(->9) (for square lattice) or 1->7(->7) (for triangular lattice).
The basic idea is to add self-energy to the CSR in a single terminal setup.
The point here is that each part has lattice momenta as parameter, to conceptually accommondate the infiniteness of the device in one or two dimensions.
*)


(*HBlochsForSpecFunc[vk_, ptscellsvas_, tfunc_, dup_] :=
Module[{HLeadIntraInterReal, HCSRIntraLeadInterReal, fillfunc, keys = Keys[ptscellsvas], len = Length[ptscellsvas]},
	(*fillfunc[indfs_, indi_] := HMatrixFromHoppings[{#, ptscellsvas[[indi]]}, tfunc, dup] & /@ KeyMap[# - keys[[indi]] &][ptscellsvas[[indfs]]];*)
	fillfunc[indfs_, indi_] := HMatrixFromHoppings[{#, ptscellsvas[[indi]]}, tfunc, dup] & /@ ptscellsvas[[indfs]];
	HLeadIntraInterReal = fillfunc @@@ {{2;;4, 3}, {2;;4, 1}};
	HCSRIntraLeadInterReal = fillfunc @@@ {{5;;, 6}, {5;;, 3}};
	Map[HBlochFull[vk, #]&, {HLeadIntraInterReal, HCSRIntraLeadInterReal}, {2}]
]*)

PhotonBlocks[{A0_, Avecn:(_Function|_Symbol), \[Omega]_}, mnup_Integer][ptf_, pti_] :=
Module[{vd = ptf - pti, zero = 1.*^-5, d, ele, dim = (2 mnup + 1){1, 1}, photondress, sparsezero, sparseid, sparsediag},
	(*A0 -> q A0/\[HBar], \[Omega] -> \[HBar] \[Omega]*)
	d = Norm[vd];
	ele[m_, n_] := 1/(2\[Pi]) NIntegrate[Exp[I (A0 vd . Avecn[\[CurlyPhi]] + (m - n) \[CurlyPhi])], {\[CurlyPhi], -\[Pi], \[Pi]}, Method -> "LocalAdaptive"] // Chop;
	(*ele[m_,n_]:=Module[{\[CurlyPhi]},
	\[CurlyPhi]=ArcTan@@Reverse[vd]+\[Pi];
	Exp[-\[ImaginaryI](m-n) \[CurlyPhi]]BesselJ[m-n,A0 d]//N
	];*)
	photondress := Array[ele, dim, -mnup] // Chop;
	(*sparseconst[i_] := ConstantArray[i, dim, SparseArray];(*\:4f4e\:7ea7\:9519\:8bef\:ff01\:ff01\:ff01*)*)
	sparsezero = ConstantArray[0, dim, SparseArray];
	sparseid = IdentityMatrix[dim, SparseArray];
	sparsediag := SparseArray[Band[{1, 1}]-> -\[Omega] Range[-mnup, mnup]];
	If[d > zero,
		{photondress, sparsezero},
		{sparseid, sparsediag}
	]
];

PhotonDress[t_, photonblocks_] :=
Module[{n = Length[t], s},
	s = IdentityMatrix[n, SparseArray];
	(*t~KroneckerProduct~a+IdentityMatrix[n,SparseArray]~KroneckerProduct~b*)
	MapThread[KroneckerProduct, {{t, s}, photonblocks}] // Total
];

(*
PRA 105, 053717 (2022),
arXiv: 2412.04352 (2024).
Constructive discussions from Zhen Qin, Ziming Wang, Fangyang Zhan, and Zhen Ning
*)
comm[a_, b_] := a . b - b . a;
flqReprAlt[flqinnerdim_Integer][mat_] := SparseArray[Transpose[Partition[mat, flqinnerdim {1, 1}], {3, 4, 1, 2}]]

HFloquetEffectiveBlochMatrixFromExtended[\[Omega]_, mnup_Integer][hmatrixfromhopping_] :=
Module[{dim = 2mnup + 1, Hs, H0},
	(*Hs = Transpose[Partition[hmatrixfromhopping, dim{1, 1}], {3, 4, 1, 2}] // SparseArray;*)
	Hs = flqReprAlt[dim][hmatrixfromhopping];
	H0 = Hs[[mnup + 1, mnup + 1]];
	H0 + 1/\[Omega] Sum[comm[Hs[[1, i]], Hs[[i, 1]]]/(i - 1), {i, 2, dim}]
];

HFloquetEffectiveHoppingMatricesFromExtended[\[Omega]_, mnup_Integer][h0isvas_Association] :=
Module[{dim = 2mnup + 1, hsvas, hefffunc, H0, h0s0i, h0isvasrepralt, h0isvasalleffective, zero = 1.*^-5},
	hefffunc[{va1_ -> h1_, va2_ -> h2_}] := (va1 + va2) -> 1/\[Omega] Sum[comm[h1[[1, i]], h2[[i, 1]]]/(i - 1), {i, 2, dim}];
	(*h0isvasrepralt = SparseArray[Transpose[Partition[#, dim{1, 1}], {3, 4, 1, 2}]] & /@ h0isvas;*)
	h0isvasrepralt = flqReprAlt[dim] /@ h0isvas;
	h0s0i = Normal[h0isvasrepralt[[;;, mnup + 1, mnup + 1]]];
	hsvas = Normal[h0isvasrepralt];
	h0isvasalleffective = Join[h0s0i, hefffunc /@ Tuples[hsvas, 2]];
	DeleteCases[s_ /; s["Density"] < zero][GroupBy[h0isvasalleffective, Keys -> Values, Chop @* Total]]
];


CompiledSuccessfulQ[cfunc_] := Echo[StringTemplate["Function compilation successful: ``"][StringFreeQ["MainEvaluate"][CompiledFunctionTools`CompilePrint[cfunc]]]];


CrystalStructure[vasbasis_, atombasis:coordspattern(*{__List}|{Rule[_,_List]..}*), vRs:{{(_Integer|_Rational)..}..}] :=
Module[{latticepoints},
	latticepoints = vRs . vasbasis;
	Which[
		MatchQ[atombasis, {__List}], <|# -> TranslationTransform[#][atombasis] & /@ latticepoints|>,
		MatchQ[atombasis, {Rule[_, _List]..}], <|# -> MapAt[TranslationTransform[#], {All, 2}][atombasis] & /@ latticepoints|>
	]
];

HEffectiveMatrix[hbloch_, vk_, vk0_, dims: {__}, orderup_Integer:1] :=
Module[{hvk, s, expansion},
	hvk = ComplexExpand[Normal[hbloch[s vk - vk0]]];
	expansion = Normal[Series[hvk, {s, 0, orderup}]] /. s -> 1;
	PauliGellMannDecomposition[expansion, dims] // FullSimplify
];


LatticePointsCentralize[data_] :=
If[FreeQ[Rule][data],
	TranslationTransform[-Mean[#]][#] & [data],
	MapAt[TranslationTransform[-Mean[Values[#]]], {All, 2}][#] & [data]
];


AdatomLabel[
	vasbasis_,
	dup_Real,
	binlbl:{_, _}:{1, 0},
	bdrcond:("PBC" | "OBC"):"PBC"
	][
	ptscell0:{({__} | Rule[_, {__}]..)..},
	adatomposres:{{__}..},
	adatominds:(_Integer | {__Integer})] :=
Module[{nfuncref, nfuncpts, distfuncref,
	adatomposes, ptswithadatomsinds, zero = 1.*^-4,
	ptscell0coords = If[FreeQ[#, Rule], #, Values[#]] & [ptscell0],
	len = Length[ptscell0], adatomlbls, func},
	distfuncref = Which[
		bdrcond == "PBC", Norm@Mod[LinearSolve[vasbasis\[Transpose]][# - #2], 1] &,
		bdrcond == "OBC", EuclideanDistance
		];
	nfuncref = Nearest[adatomposres -> "Element", DistanceFunction -> distfuncref];
	adatomposes = nfuncref[adatomposres[[adatominds]], {All, zero}];
	nfuncpts = Nearest[ptscell0coords -> "Index"];
	ptswithadatomsinds = Union[Flatten[nfuncpts[#, {All, dup}] & /@ adatomposes]];
	adatomlbls = SparseArray[Thread[ptswithadatomsinds -> #], len, #2] & @@ binlbl;
	func = If[FreeQ[ptscell0, Rule],
		Rule,
		{newlbl, oript} |-> MapAt[Flatten[{#, newlbl}] &, 1][oript]
		];
	MapThread[func][{adatomlbls, ptscell0}]
];

HCSRBlocksAndersonDisordered[W_, nensemble_Integer:1, innerdofmat_][hdods:{{__}, {__}}] :=
Module[{hds, hods, hdsdisordered, hdsensemble, innerdof = Length[innerdofmat], disorderblock},
	{hds, hods} = hdods;
	disorderblock = DiagonalMatrix[RandomReal[{-1, 1} W/2, Length[#]/innerdof], TargetStructure -> "Sparse"] &;
	hdsdisordered := # + KroneckerProduct[disorderblock[#], innerdofmat] & /@ hds;
	Table[{hdsdisordered, hods}, nensemble]
];


tSKOnsiteBlock["ss"][Vs_] := {{Vs}};
tSKOnsiteBlock["pp"][Vp_] := DiagonalMatrix[ConstantArray[Vp, 3], TargetStructure -> "Sparse"];
tSKOnsiteBlock["dd"][Vd_] := DiagonalMatrix[ConstantArray[Vd, 5], TargetStructure -> "Sparse"];

SlaterKosterOnsiteBlock["sp"][{Vs_, Vp_}] :=
Module[{ss, pp},
	ss = tSKOnsiteBlock["ss"][Vs];
	pp = tSKOnsiteBlock["pp"][Vp];
	BlockDiagonalMatrix[{ss, pp}]
];

SlaterKosterOnsiteBlock["spd"][{Vs_, Vp_, Vd_}] :=
Module[{ss, pp, dd},
	ss = tSKOnsiteBlock["ss"][Vs];
	pp = tSKOnsiteBlock["pp"][Vp];
	dd = tSKOnsiteBlock["dd"][Vd];
	BlockDiagonalMatrix[{ss, pp, dd}]
];


tSKBlock["ss"][vecV:{Vss\[Sigma]_}][ptf_, pti_] :=
Module[{},
	{{Vss\[Sigma]}}
];(*1 by 1*)

tSKBlock["sp"][vecV:{Vsp\[Sigma]_}][ptf_, pti_] :=
Module[{vd = ptf - pti, d, l, m, n, coeffmat},
	d = Norm[vd]; {l, m, n} = Normalize[vd];
	coeffmat = {{{l}, {m}, {n}}};
	coeffmat . vecV
];(*1 by 3*)

tSKBlock["sd"][vecV:{Vsd\[Sigma]_}][ptf_, pti_] :=
Module[{vd = ptf - pti, d, l, m, n, coeffmat},
	d = Norm[vd]; {l, m, n} = Normalize[vd];
	coeffmat = {{{Sqrt[3]l m}, {Sqrt[3]m n}, {Sqrt[3]n l}, {Sqrt[3](l^2-m^2)/2}, {n^2-(l^2+m^2)/2}}};
	coeffmat . vecV
];(*1 by 5*)

tSKBlock["pp"][vecV:{Vpp\[Sigma]_, Vpp\[Pi]_}][ptf_, pti_] :=
Module[{vd = ptf - pti, d, l, m, n, coeffmat},
	d = Norm[vd]; {l, m, n} = Normalize[vd];
	coeffmat =
	{{{l^2, 1-l^2}, l m {1, -1}, l n {1, -1}},
	{m l {1, -1}, {m^2, 1-m^2}, m n {1, -1}},
	{n l {1, -1}, n m {1, -1}, {n^2, 1-n^2}}};
	coeffmat . vecV
];(*3 by 3*)

tSKBlock["pd"][vecV:{Vpd\[Sigma]_, Vpd\[Pi]_}][ptf_, pti_] :=
Module[{vd = ptf - pti, d, l, m, n, coeffmat},
	d = Norm[vd]; {l, m, n} = Normalize[vd];
	coeffmat =
	{{m{Sqrt[3] l^2, 1-2l^2}, l m n{Sqrt[3], -2}, n {Sqrt[3] l^2, 1-2l^2}, l{Sqrt[3](l^2-m^2)/2, 1-(l^2-m^2)}, l{(3n^2-1)/2, -Sqrt[3] n^2}},
	{l{Sqrt[3] m^2, 1-2m^2}, n{Sqrt[3] m^2, 1-2m^2}, m n l{Sqrt[3], -2}, m{Sqrt[3](l^2-m^2)/2, -1-(l^2-m^2)}, m{(3n^2-1)/2, -Sqrt[3] n^2}},
	{n l m{Sqrt[3], -2}, m{Sqrt[3] n^2, 1-2n^2}, l{Sqrt[3] n^2, 1-2n^2}, n{Sqrt[3](l^2-m^2)/2, -(l^2-m^2)}, n{(3n^2-1)/2, Sqrt[3](1-n^2)}}};
	coeffmat . vecV
];(*3 by 5*)

tSKBlock["dd"][vecV:{Vdd\[Sigma]_, Vdd\[Pi]_, Vdd\[Delta]_}][ptf_, pti_] :=
Module[{vd = ptf - pti, d, l, m, n, coeffmat(*,\[Eta],\[Xi]*)},
	d = Norm[vd]; {l, m, n} = Normalize[vd];(*\[Eta]=l^2-m^2;\[Xi]=1-n^2;*)
	(*coeffmat={{{3l^2m^2,l^2+m^2-4l^2m^2,n^2+l^2m^2},n l{3m^2,1-4m^2,m^2-1},m n{3l^2,1-4l^2,l^2-1},l m \[Eta]{3,-4,1}/2,Sqrt[3]l m{3n^2-1,-4n^2,1+n^2}/2},
	{n l{3m^2,1-4m^2,m^2-1},{3m^2n^2,m^2+n^2-4m^2n^2,l^2+m^2n^2},l m{3n^2,1-4n^2,n^2-1},m n (\[Eta]{3,-4,1}/2+{0,-1,1}),Sqrt[3]m n({3n^2-1,-4n^2,-1+n^2}/2+{0,1,0})},
	{m n{3l^2,1-4l^2,l^2-1},l m{3n^2,1-4n^2,n^2-1},{3n^2l^2,n^2+l^2-4n^2l^2,m^2+n^2l^2},n l (\[Eta]{3,-4,1}/2+{0,1,-1}),Sqrt[3]n l({3n^2-1,-4n^2,-1+n^2}/2+{0,1,0})},
	{{},{},{},{3\[Eta]^2/4,\[Xi]-\[Eta],n^2+\[Eta]/4},Sqrt[3]\[Eta]/4{3\[Xi]-4,-4n^2,1+n^2}},
	{{},{},n l{3\[Eta]/2,-2\[Eta]+1,\[Eta]/2-1},Sqrt[3]\[Eta]/4{3\[Xi]-4,-4n^2,1+n^2},{(3\[Xi]-4)^2/4,3n^2\[Xi],3\[Xi]^2/4}}};*)
	coeffmat=
	{{{3l^2 m^2, m^2+l^2 (1-4m^2), l^2 m^2+n^2}, {3l m^2 n, l(1-4m^2)n, l(-1+m^2)n}, {3l^2 m n, (1-4l^2)m n, (-1+l^2)m n}, {3/2 l m(l^2-m^2), 2l m(-l^2+m^2), 1/2 l m(l^2-m^2)}, {-(1/2) Sqrt[3]l m(l^2+m^2-2n^2), -2 Sqrt[3]l m n^2, 1/2 Sqrt[3]l m(1+n^2)}},
	{{3l m^2 n, l(1-4m^2)n, l(-1+m^2)n}, {3m^2 n^2, n^2+m^2 (1-4n^2), l^2+m^2 n^2}, {3l m n^2, l m(1-4n^2), l m(-1+n^2)}, {3/2 m(l^2-m^2)n, m(-1-2l^2+2m^2)n, -(1/2)m(-2-l^2+m^2)n}, {-(1/2) Sqrt[3]m n(l^2+m^2-2n^2), Sqrt[3]m n(l^2+m^2-n^2), -(1/2) Sqrt[3]m(l^2+m^2)n}},
	{{3l^2 m n, (1-4l^2)m n, (-1+l^2)m n}, {3l m n^2, l m(1-4 n^2), l m(-1+n^2)}, {3l^2 n^2, n^2+l^2 (1-4n^2), m^2+l^2 n^2}, {3/2 l(l^2-m^2)n, l(1-2l^2+2m^2)n, 1/2 l(-2+l^2-m^2)n}, {-(1/2) Sqrt[3]l n(l^2+m^2-2n^2), Sqrt[3]l n(l^2+m^2-n^2), -(1/2) Sqrt[3]l(l^2+m^2)n}},
	{{3/2 l m(l^2-m^2), 2l m(-l^2+m^2), 1/2 l m(l^2-m^2)}, {3/2 m(l^2-m^2)n, m(-1-2l^2+2m^2)n, -(1/2)m(-2-l^2+m^2)n}, {3/2 l(l^2-m^2)n, l(1-2l^2+2m^2)n, 1/2 l(-2+l^2-m^2)n}, {3/4 (l^2-m^2)^2, l^2+m^2-(l^2-m^2)^2, 1/4 (l^2-m^2)^2+n^2}, {-(1/4) Sqrt[3](l^2-m^2)(l^2+m^2-2n^2), Sqrt[3](-l^2+m^2)n^2, 1/4 Sqrt[3](l^2-m^2)(1+n^2)}},
	{{-(1/2) Sqrt[3]l m(l^2+m^2-2n^2), -2 Sqrt[3]l m n^2, 1/2 Sqrt[3]l m(1+n^2)}, {-(1/2) Sqrt[3]m n(l^2+m^2-2n^2), Sqrt[3]m n(l^2+m^2-n^2),-(1/2) Sqrt[3]m(l^2+m^2)n}, {-(1/2) Sqrt[3]l n(l^2+m^2-2n^2), Sqrt[3]l n(l^2+m^2-n^2), -(1/2) Sqrt[3]l(l^2+m^2)n}, {-(1/4) Sqrt[3](l^2-m^2)(l^2+m^2-2n^2), Sqrt[3](-l^2+m^2)n^2, 1/4 Sqrt[3](l^2-m^2)(1+n^2)}, {1/4 (l^2+m^2-2n^2)^2, 3(l^2+m^2)n^2, 3/4 (l^2+m^2)^2}}};
	coeffmat . vecV
];(*5 by 5*)


SlaterKosterHoppingBlock["sp"][Vvec:{Vss\[Sigma]_, Vsp\[Sigma]_, Vpp\[Sigma]_, Vpp\[Pi]_}][ptf_, pti_] := SlaterKosterHoppingBlock["sp"][{Vss\[Sigma], Vsp\[Sigma], Vsp\[Sigma], Vpp\[Sigma], Vpp\[Pi]}][ptf, pti] /; Length[Vvec] == 4;
SlaterKosterHoppingBlock["sp"][Vvec:{Vss\[Sigma]_, Vsp\[Sigma]_, Vps\[Sigma]_, Vpp\[Sigma]_, Vpp\[Pi]_}][ptf_, pti_] :=
Module[{ss, pp, sp, ps},
	ss = tSKBlock["ss"][{Vss\[Sigma]}][ptf, pti];
	sp = tSKBlock["sp"][{Vsp\[Sigma]}][ptf, pti];
	pp = tSKBlock["pp"][{Vpp\[Sigma], Vpp\[Pi]}][ptf, pti];
	ps = -tSKBlock["sp"][{Vps\[Sigma]}][ptf, pti]\[Transpose];
	
	ArrayFlatten[({
 {ss, sp},
 {ps, pp}
})]
] /; Length[Vvec] == 5;

SlaterKosterHoppingBlock["spd"][Vvec:
	{Vss\[Sigma]_, Vsp\[Sigma]_, Vsd\[Sigma]_,
	 Vpp\[Sigma]_, Vpp\[Pi]_, Vpd\[Sigma]_, Vpd\[Pi]_,
	 Vdd\[Sigma]_, Vdd\[Pi]_, Vdd\[Delta]_}][ptf_, pti_] :=
SlaterKosterHoppingBlock["spd"][
	{Vss\[Sigma], Vsp\[Sigma], Vsd\[Sigma],
	 Vsp\[Sigma], Vpp\[Sigma], Vpp\[Pi], Vpd\[Sigma], Vpd\[Pi],
	 Vsd\[Sigma], Vpd\[Sigma], Vpd\[Pi], Vdd\[Sigma], Vdd\[Pi], Vdd\[Delta]}][ptf, pti] /; Length[Vvec] == 10;
	
SlaterKosterHoppingBlock["spd"][Vvec:
	{Vss\[Sigma]_, Vsp\[Sigma]_, Vsd\[Sigma]_,
	 Vps\[Sigma]_, Vpp\[Sigma]_, Vpp\[Pi]_, Vpd\[Sigma]_, Vpd\[Pi]_,
	 Vds\[Sigma]_, Vdp\[Sigma]_, Vdp\[Pi]_, Vdd\[Sigma]_, Vdd\[Pi]_, Vdd\[Delta]_}][ptf_, pti_] :=
Module[{ss, sp, sd, pp, pd, dd, ps, dp, ds},
	(*
	11 13 15;
	31 33 35;
	51 53 55;
	*)
	ss = tSKBlock["ss"][{Vss\[Sigma]}][ptf, pti];
	pp = tSKBlock["pp"][{Vpp\[Sigma], Vpp\[Pi]}][ptf, pti];
	dd = tSKBlock["dd"][{Vdd\[Sigma], Vdd\[Pi], Vdd\[Delta]}][ptf, pti];
	
	sp = tSKBlock["sp"][{Vsp\[Sigma]}][ptf, pti];
	sd = tSKBlock["sd"][{Vsd\[Sigma]}][ptf, pti];
	pd = tSKBlock["pd"][{Vpd\[Sigma], Vpd\[Pi]}][ptf, pti];
	
	ps = -tSKBlock["sp"][{Vps\[Sigma]}][ptf, pti]\[Transpose]; (*transposition or conjugate transposition, hidden flaw point*)
	dp = -tSKBlock["pd"][{Vdp\[Sigma], Vdp\[Pi]}][ptf, pti]\[Transpose];
	ds = tSKBlock["sd"][{Vds\[Sigma]}][ptf, pti]\[Transpose];
	
	ArrayFlatten[({
 {ss, sp, sd},
 {ps, pp, pd},
 {ds, dp, dd}
})]
] /; Length[Vvec] == 14;


\[Lambda]SKOnsiteBlock["ss"][\[Lambda]_] := ConstantArray[0, {1, 1}2, SparseArray];
\[Lambda]SKOnsiteBlock["sp"][\[Lambda]_] := ConstantArray[0, {1, 3}2, SparseArray];
\[Lambda]SKOnsiteBlock["sd"][\[Lambda]_] := ConstantArray[0, {1, 5}2, SparseArray];
\[Lambda]SKOnsiteBlock["pd"][\[Lambda]_] := ConstantArray[0, {3, 5}2, SparseArray];
\[Lambda]SKOnsiteBlock["pp"][\[Lambda]_] := I \[Lambda] SparseArray[ArrayFlatten[({
 {0, -PauliMatrix[3], PauliMatrix[2]},
 {PauliMatrix[3], 0, -PauliMatrix[1]},
 {-PauliMatrix[2], PauliMatrix[1], 0}
})]];
\[Lambda]SKOnsiteBlock["dd"][\[Lambda]_] := I \[Lambda] SparseArray[ArrayFlatten[({
 {0, PauliMatrix[2], -PauliMatrix[1], 2PauliMatrix[3], 0},
 {-PauliMatrix[2], 0, PauliMatrix[3], -PauliMatrix[1], -Sqrt[3]PauliMatrix[1]},
 {PauliMatrix[1], -PauliMatrix[3], 0, -PauliMatrix[2], Sqrt[3]PauliMatrix[2]},
 {-2PauliMatrix[3], PauliMatrix[1], PauliMatrix[2], 0, 0},
 {0, Sqrt[3]PauliMatrix[1], -Sqrt[3]PauliMatrix[2], 0, 0}
})]];

SlaterKosterSOCOnsiteBlock["sp"][\[Lambda]_] :=
Module[{ss, sp, ps, pp},
	ss = \[Lambda]SKOnsiteBlock["ss"][\[Lambda]];
	sp = \[Lambda]SKOnsiteBlock["sp"][\[Lambda]];
	ps = sp\[Transpose];
	pp= \[Lambda]SKOnsiteBlock["pp"][\[Lambda]];
	
	ArrayFlatten[({
 {ss, sp},
 {ps, pp}
})]
];

SlaterKosterSOCOnsiteBlock["spd"][\[Lambda]_] :=
Module[{ss, sp, sd, ps, pp, pd, ds, dp, dd},
	ss = \[Lambda]SKOnsiteBlock["ss"][\[Lambda]];
	sp = \[Lambda]SKOnsiteBlock["sp"][\[Lambda]];
	sd = \[Lambda]SKOnsiteBlock["sd"][\[Lambda]];
	ps = sp\[Transpose];
	pp = \[Lambda]SKOnsiteBlock["pp"][\[Lambda]];
	pd = \[Lambda]SKOnsiteBlock["pd"][\[Lambda]];
	ds = sd\[Transpose];
	dp = pd\[Transpose];
	dd = \[Lambda]SKOnsiteBlock["dd"][\[Lambda]];
	
	ArrayFlatten[({
 {ss, sp, sd},
 {ps, pp, pd},
 {ds, dp, dd}
})]
];


End[] (* End `Private` *)

EndPackage[]
